import Foundation

// n개의 풍선

// 1개가 남을 때까지 터트린다.

// 임의의 연속된 풍선 2개 -> 1개 터트림
// 빈공간 생겼다면 밀착

// 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만

// 더 작은 풍선을 터트리는 건 딱 1번

// 풍선 번호 배열 a
// return 남기는 것이 가능한 풍선의 개수


// a: 1~100만 -> O(N)
// a: -10억~10억 -> 80억 바이트 / 배열로 저장 불가 (8GB)

// 풀이

// 요소가 중요한것은 아니다.
// 개수만 세면 되는 상황 & 크기 비교만 하면 되는 상황

// [완전 탐색] - 시간 초과
    // 작은 것 선택할 순서 찾기 (100만번 터트리는 동안 1번)
    // O(100만 * 100만)

// [BFS] - 시간 초과
    // O(100만 * 100만)

// [그리디] - 최적해 놓침
    // 이전의 선택이 현재 선택에 영향을 준다.

// [DP] - a의 배열의 순서가 변경되면 결과는 바뀐다.
    // 공간 초과 - O(100만 * 100만 * 2) - 16GB

// 1. 터트릴 풍선은 답이 정해져있다.
// 2. 딱 1번 결과를 뒤집을 수 있다.

// 결론적으로 n개라면, 적어도 n-2개는 큰 풍선 날려야함.

// <부분집합으로 생각>
// DP는 결국 부분 집합으로 -> 큰 집합을 해결하는 문제

// 1. 결과를 안 뒤집으면 남는 건 최솟값
// 2. 

// 왼쪽 최솟값과 오른쪽 최솟값보다 모두 크다? 불가능
// D[i][0] = i 인덱스 왼쪽 수 중 최솟값
// D[i][1] = i 인덱스 오른쪽 수 중 최솟값

func solution(_ a:[Int]) -> Int {
    
    let INF = 1_000_000_001
    var D = [[Int]](repeating: [INF,INF], count: a.count)
    
    if a.count < 3 {
        return a.count
    }
    
    D[0][0] = INF
    D[1][0] = a[0]
    // D[i][0] = min(D[i-1][0], a[i-1])
    
    for i in 1...a.count-1 {
        D[i][0] = min(D[i-1][0], a[i-1])
    }
    
    D[a.count-1][1] = INF
    D[a.count-2][1] = a[a.count-1]
    // D[i][1] = min(D[i+1][1], a[i+1])
    
    for i in (0...a.count-2).reversed() {
        D[i][1] = min(D[i+1][1], a[i+1])
    }
    
    var ans = 0
    for i in 0..<a.count {
        if a[i] > D[i][0] && a[i] > D[i][1] { continue }
        ans += 1
    }
    
    return ans
}